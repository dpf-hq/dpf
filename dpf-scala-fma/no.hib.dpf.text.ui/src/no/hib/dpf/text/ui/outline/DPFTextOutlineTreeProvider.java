/*
 * generated by Xtext
 */
package no.hib.dpf.text.ui.outline;

import no.hib.dpf.text.tdpf.Arrow;
import no.hib.dpf.text.tdpf.Arrows;
import no.hib.dpf.text.tdpf.ChoosenGraph;
import no.hib.dpf.text.tdpf.Definition;
import no.hib.dpf.text.tdpf.Model;
import no.hib.dpf.text.tdpf.Node;
import no.hib.dpf.text.tdpf.TdpfFactory;
import no.hib.dpf.text.ui.GraphNormalizer;

import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.graphics.Image;
import org.eclipse.text.edits.ReplaceEdit;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.nodemodel.ICompositeNode;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.ILocationInFileProvider;
import org.eclipse.xtext.ui.editor.XtextEditor;
import org.eclipse.xtext.ui.editor.model.IXtextDocument;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;
import org.eclipse.xtext.util.ITextRegion;

import com.google.inject.Inject;


public class DPFTextOutlineTreeProvider extends DefaultOutlineTreeProvider {

	@Inject
	protected ILocationInFileProvider locationInFileProvider;
	
	@Inject
	protected XtextEditor xtextEditor;
	
	protected IXtextDocument document;
	
//	boolean autocompleteIds = false; Init before save and after loading
	boolean isInited = true; //TEST false;
	
	public DPFTextOutlineTreeProvider(){
		//editor.addPartPropertyListener(listener);
	}
	
	
	protected void _createChildren(final DocumentRootNode parentNode, final Model model) {
		//Init:
		if(!isInited){
		   init(model);
		}
		for (Definition d : model.getDefinitions()) {
			createNode(parentNode, d);
		}
	}

	//
	//Document:
	//
	@Override
	public IOutlineNode createRoot(IXtextDocument d){
		this.document = d;
		GraphNormalizer.setDocument(d);
		return super.createRoot(d);
	}
	
	public void init(final Model model){
		//
		//Add missing Ids: (while keeping comments)
		//
		final ICompositeNode c = NodeModelUtils.findActualNodeFor(model);
		final StringBuffer buffer = new StringBuffer();
//		BidiTreeIterator<INode> ti = c.getAsTreeIterable().iterator();
//		StringBuffer cache = new StringBuffer();
//		boolean incompleteDpfId=false;
//		DpfId id = null;
//		while(ti.hasNext()){
//			final INode n = ti.next();
//			if(n instanceof LeafNode){		
//				if(n.getSemanticElement() instanceof DpfId){
//					id = (DpfId)n.getSemanticElement(); 
//					if(id.getId() < 1){
//						incompleteDpfId=true;
//						cache.append(n.getText());
//					}else{
//						buffer.append(n.getText());
//					}
//				}else{
//					if(incompleteDpfId){
//						buffer.append(cache.toString().replaceFirst(id.getName(),id.getName() + "@100"));
//						cache = new StringBuffer();
//					    incompleteDpfId=false;
//					}
//					buffer.append(n.getText());
//				}
//			}
//		}
		
		
		
		//
		//Add automatic all IDs at once: 
		//
		final ReplaceEdit r = new ReplaceEdit(0,document.getLength(),buffer.toString());	
		try {
			r.apply(document,ReplaceEdit.NONE);
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		this.isInited=true;
	}
	
	
	//
	// Graph:
	//
	protected void _createNode(IOutlineNode parentNode, ChoosenGraph name) {
	}

	//
	// Arrow:
	//
	/**
	 * Create Arrow for outline view:
	 * @param parentNode
	 * @param arrow
	 */
	protected void _createNode(IOutlineNode parentNode, Arrow arrow) {
		Image image = imageDispatcher.invoke(arrow);
		EObjectNode eObjectNode = new EObjectNode(arrow, parentNode, image, makeLabel(arrow), true);
		ITextRegion location = locationInFileProvider.getSignificantTextRegion(arrow.getId());
		eObjectNode.setShortTextRegion(location);
	}
	
	/**
	 * Make Label for an Arrow
	 * @param arrow
	 * @return
	 */
	protected StyledString makeLabel(Arrow arrow) {
		try {			
			final String id = arrow.getId().getName() + "@" + arrow.getId().getId() + ":" +
							  (null!=arrow.getType()?arrow.getType().getName() + "@" + arrow.getType().getId():"Attribute");
			final String sr = arrow.getSr().getId().getName() + "@" + arrow.getSr().getId().getId() + ":" 
						     + arrow.getSr().getType().getName() + "@" + arrow.getSr().getType().getId();
			String tg = "";		
			//Target:
			if(null != arrow.getTgNode()){
				Node n = arrow.getTgNode();
				tg = makeLabel(n);
			}
			else if(null != arrow.getTgValue()){
				tg = arrow.getTgValue().getValue();
			}
			else if(null != arrow.getTgDataType()){
				tg = arrow.getTgDataType().getName() + ":Datatype";
			}		
			final StyledString ret = new StyledString(sr + " --- " + id + " ---> " + tg);
			ret.setStyle(sr.length() + 1,id.length()+10, StyledString.COUNTER_STYLER);
		return ret;
		} catch (Exception e) {
			System.out.println("Source: " + arrow.getSr());
			System.out.println("Type  : " + arrow.getType());
			return new StyledString("Problem with arrow: " + arrow.getId().getName());
		}
	}

	/**
	 * Split Arrow-List into to sequence of Arrows
	 * @param parentNode
	 * @param arrows
	 */
	protected void _createNode(IOutlineNode parentNode, Arrows arrows) {
		
		//Create head arrow:
		Arrow a = TdpfFactory.eINSTANCE.createArrow();
		a.setId(arrows.getId());
		a.setType(arrows.getType());
		a.setSr(EcoreUtil2.clone(arrows.getSr()));
		Arrows next = arrows.getNext();
		a.setTgNode(EcoreUtil2.clone(next.getSr()));
		_createNode(parentNode, a);
		
		//Call either creation method for arrow or arrows:
		if(next instanceof Arrow){
			_createNode(parentNode, (Arrow) next);
		}else{
			_createNode(parentNode, (Arrows) next);
		}
			
	}
	
	//
	// Node:
	//
	/**
	 * Create Arrow for outline view:
	 * @param parentNode
	 * @param arrow
	 */
	protected void _createNode(IOutlineNode parentNode, Node node) {
		Image image = imageDispatcher.invoke(node);
		EObjectNode eObjectNode = new EObjectNode(node, parentNode, image, new StyledString(makeLabel(node)), true);
		eObjectNode.setShortTextRegion(locationInFileProvider.getSignificantTextRegion(node.getId()));
	}
	
	/**
	 * Make Label for a Node
	 * @param n
	 * @return
	 */
	private String makeLabel(Node n) {
		String tg;
		tg = n.getId().getId() + "@" + n.getId().getName() + ":"
		   + n.getType().getName() + "@" + n.getType().getId();
		return tg;
	}
	
	
}
