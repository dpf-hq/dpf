%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[pdftex,11pt,a4paper]{article}

\usepackage{graphicx}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{url}

\begin{document}

\title{Analyzing Model to Model Transformation
	   Tools}
\date{April 23}
\author{Petter Barvik}

\maketitle
\section{Introduction}

Model Driven Engineering(MDE)\cite{France2007} thrives to raise the level of abstraction in
program specification and increase automation in program development. The idea
from MDE is to use models at different levels of abstraction when developing
applications. Therefore raising the level of abstraction in program
specification. This level of abstraction is fulfilled either through extensive
use of models to describe some design patterns in a software application or
through use of standardized models. The first option is probably an element of
MDE that is most common among software engineers. That you implement some aspect
of a system based on a model of a specific language. Unified Modelling Language is
an example of an modelling language often used to describe system design
patterns in an application domain. The second principle of Model Driven
Engineering is to increase automation in program development, and to obtain this
we use something called model transformations. \\
\indent A model transformation is when we change some source model from one
instance to another instance and end up with a targeted model. We can
distinguish these operations into either endogenous or exogenous model
transformations. In an endogenous model transformation we take one model
expressed in a language and produce a model expressed in the same language.
While in an exogenous model transformation we produce a model expressed in a
different language. It is essential that these models are consistent. This is
obtained through the use of metamodels. A metamodel is an abstraction of a
model, where it defines elements that are used in the model. Models in a
system is consistent if the source and target model conforms to some unique 
metamodel. This way system developers can safely presume that a model has
changed accordingly to its metamodel and therefore is consistent. A target model
can produce two different kind of output models. The first one is code
generation, often referred to Model to Text(M2T) transformation, and it takes
one model and produces implementation code. This is convenient if for example a software
engineer wants to produce source code from a given model. The latter is often
referred to Model to Model(M2M) transformations, that is also the subject of
my master thesis. M2M transformations take a model as input and produces a model
as output. In this article we try and go into depth for some model
transformation tools. These tools are Henshin, AGG and ATL. Henshin and AGG is
build around graph transformation. 

\subsection{The Model Instances}
The task was to take a certain instance of model transformation, in this case
translating a activity diagram, written in the language UML and
transform it to petri net. We initialize the metamodels to make sure that the
models remain consistent.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{figures/ActivityMetamodel.png}
	\caption{Metamodel of Activity Diagram }
	\label{fig:ActivityMetamodel}
\end{figure}

The metamodel of an activity diagram has an arbitrary number of activity and
next elements. An activity element can have a name and can be of some type kind.
Example of activity types can be decision or simple. The next element can have
an inscription and has the property to either start or end an activity. The
collection of activity and next elements have to have an activity diagram that
they belong to. Now we have defined the metamodel that the source model should
conform to. To keep consistency between the models we need to have a
metamodel for the target model.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{figures/PetriNetsMetamodel.png}
	\caption{Metamodel of Petri nets}
	\label{fig:PetriNetsMetamodel}
\end{figure}

The metamodel for a petri net consist of places and transitions. A petri net
instance must have a place connected to a transition or the other way around.
But a petri net can never have two of the same types connected with each other.
There also is two nodes that distinguish if the arrow has a place or a
transition as source node and the opposite as target node.

\section{Graph Transformation}
One approach to model transformations is by graph transformations, also referred
to as graph rewriting. And one approach to graph rewriting is an algebraic
approach, which is based upon category theory\cite{Barr1990}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{figures/categoryTheory.png}
	\caption{Collection of objects A,B and C}
	\label{fig:categoryTheory}
\end{figure}

In category theory there are a collection of objects and arrows. These arrows
are also called morphisms. In figure~\ref{fig:categoryTheory} we have a
collection of objects A, B and C and morphisms f, g and g o f. Category
theory can then be used to formalize concepts of high-level abstractions. 

This approach are based on the concepts of gluing of graphs, modelled by
pushouts of graphs and graph morphisms. These pushouts comes in different
categories, and we will look a the two major ones

\subsection{Defining a set of rules}
For a transformation language to be able to execute for graph transformations a
set of rules needs to be defined. Through these rules, a transformation
interpreter can act accordingly.

\section{The Henshin Project}

The Henshin project\cite{Henshin} provides a model transformation language for the Eclipse
Modelling Framework \cite{Steinberg2009}. With support for both direct 
transformation of EMF single model instances, and translation from source
model to targeted model. The Henshin project is a transformation language with a
provided graphical syntax. With the help of this graphical editor, it provides
the user with an intuitive way of representing rules. The tool also has support 
both endogenous and exogenous transformations.

\subsection{Defining transformation rules}

In Henshin, objects are referred to as nodes and links between objects as edges.
A collection of these nodes and edges form a graph. For each graph, a rule has
to be defined. These rules can have parameters for checking and model
verification. Each rule can be represented as a graph in the graphical
editor. \newline When creating these rules, there has to be a way of
distinguishing elements between the LHS and the RHS. This is done through the use of
a set of predefined tag words, or stereotypes. For handling transformations
either in the pattern graph or the replacement graph, we can use the three
predefined words preserve, create or delete. Forbid and require are used for
defining Negative Application Conditions (NACs) and Positive Application
Conditions (PACs). These actions are supported for nodes, edges and attributes.

\section{The Attributed Graph Grammar System}

AGG is a general development environment for algebraic graph transformation
systems. AGG is provided with a graphical editor for creating and modifying
graphs. The editor provides a graphical user-interface with several visual
editors for applying the principles of graph transformation. It also has an
interpreter and a set of validation tools.

\subsection{Graphical Editor}
The graphical editor of AGG has several functions to help the user to define
model transformations. In the top left corner of the graphical user-interface is
a tree based editor for defining rules and grammar. This tree based editor also
contains the type graphs and the host graphs. Where the host graph represents
some input model for a model transformation.
\indent Each application rule has two visual editors, representing the left and
the right hand side, or the pattern and the replacement graph. In the tree
collection of rules and grammars it is possible to give rules application
conditions. This is convenient if the user wants to have constrains for the
pattern or the replacement graph. 
\indent In the tree based visual editor it is also possible to define host
graphs and type graphs. Type graphs is described more in depths in the next
section, but roughly said, the type graph defines elements that can be used in
the host graph. Type graphs defines the abstract models for the host graph and
can be compared to Meta Object Facility
(MOF)\cite{OMGAdoptedSpecificationptc/03-10-04}, that is a language for defining
abstract syntax of modeling languages. The users can now create instances
from these type graphs. These instances represents the host graphs and
corresponds to its concurrent type graph. 
\indent For the application rules, the user can extend the attributes with Java
expressions. This means that the users can use Java primitives such as strings,
integers or float numbers to form the pattern graph or the left hand side of the
rule. The user cannot bind attributes that is not initialised in the type graph. 

\subsection{Type Graph}

Before the host graphs can be created. a type graph has to be initialised. These
type graphs represents the abstract syntax for the host graphs. For this
case study we created a type graph enabling translation from an activity diagram
to petri nets. Unlike Henshin, the AGG graphs does not allow for separately
definitions of type graphs. Henshin allows the use of one source and one target
metamodel independent of each other. If we want to prepare an AGG graph for a
transformation, we create a single type graph with references between elements
of both source and target metamodel. This way, when the application rules is
executed, we can choose to keep both the source graph and the references between
these elements. The references and source graph can be deleted through a cycle
of transformation rules.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{figures/AggTypeGraph.png}
	\caption{Activity diagram to petri nets type graph in AGG}
	\label{fig:AggTypeGraph}
\end{figure}

\indent For the type graph, the user must define nodes and arrows for each
element for both source and target model. These nodes and arrows can also have
attributes. Nodes represents elements from the two modelling languages and
arrows represents the associations between these elements. In the type graph we
want to distinguish between associations and references, and therefore we
represent references as a dashed edge. These dashed edges are not given any
attributes, and that is because we want these edges to represent what the
targeted element was translated from. From figure~\ref{fig:AggTypeGraph} we can
see that a RefAct node is defined and is connected between the activity
element and the transition element. The same initialisation is defined between
the place next element and the place element. The elements presented in the
type graph for AGG graphs is very similar to the metamodels represented for
Henshin transformations. For AGG type graphs there is a multiplier condition for
the edges. This means that there can be an arbitrary, or a zero to many number of
instances of these relations in the host graph.



\pagebreak
\bibliographystyle{plain} 
\bibliography{Master,websites}

\end{document}
