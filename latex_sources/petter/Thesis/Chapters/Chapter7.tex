% Chapter Template

\chapter{Evaluation} % Main chapter title

\label{Chapter6} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 6. \emph{Evaluation}} % Change X to a consecutive
% number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Evaluation of Solution}
\label{evaluate_solution}
We have successfully managed to integrate Henshin with the Diagram Predicate
Framework to support exogenous model transformations. We have created a
Transformation Editor that communicates with the Henshin transformation language
and the interpreter engine to deliver a model transformation environment to DPF.
We can use some of the strengths that Henshin provides

\section{Future Work}

%----------------------------------------------------------------------------------------
% SECTION 2
%----------------------------------------------------------------------------------------

\section{Comparison with other editor tools}

In section~\ref{comparison} we compared strength and weaknesses of different
model transformation tools. Now that we have extended the DPF workbench
environment with the possibility to perform model to model transformations, we
should compare it with other model transformation tools. In our solution we
expanded the Henshin model transformation environment to be able to apply model
transformations to a multi-layered meta-modeling environment like we discussed
in section~\ref{evaluate_solution}. It is natural that the Transformation
Editor will have some similarities to the Henshin environment since our
solutions builds heavily on on this environment.

\subsection{Editing Transformation Rules}

In the Transformation Editor we present the transformation rules in a list of
transformation rules. Each transformation rule is extended with a simplified
version of the DPF Editor and a toolbar that contains modeling elements from a
source and a target meta-model. With these modeling elements we can create and
structure a searching pattern and a replacement pattern for each transformation
rules. It is logical that the searching pattern and replacement pattern create
modeling elements that corresponds to the source and target meta-model, since
this is an exogenous model transformation between two different modeling
languages. In Henshin we can choose to create transformation rules in either the
tree based Henshin Model Editor or in a graph based editor. The Transformation
Editor that we created provides an integrated view on transformation rules,
similar to Henshin and GReAT\cite{GReAT}. This means that we do not provide
separate editors to implicitly edit the LHS and the RHS graphs like for
example AGG does. 

\begin{table}[ht]
\renewcommand*\arraystretch{1.2}
\centering
\begin{tabular}{| c | c | c | c | c |}
\hline
& AGG & Henshin & ATL & DPF Transform \\
\hline
Endogenous transformation & $\surd$ & $\surd$ & $\surd$ & \textcolor{red}{\textbf{---}}\\

Exogenous transformation & $\surd$ & $\surd$ & $\surd$ & $\surd$\\

Input Elements & 1\ldots n & 1\ldots n & 1\ldots n & 1\ldots n\\

Output Elements & 1\ldots n & 1\ldots n & 1\ldots n & 1\ldots n\\

Graphical editor & $\surd$ & $\surd$ & \textcolor{red}{\textbf{---}} & $\surd$
\\

Meta-modeling layers & 2 & 2 & 2 & $\infty$ \\

Separate meta-models & \textcolor{red}{\textbf{---}} &  $\surd$ &  $\surd$ &  $\surd$ \\

Integrated with EMF & \textcolor{red}{\textbf{---}} & $\surd$ & $\surd$ & $\surd$ \\ 

Model transformation file size & 200 kb & 80 kb & 4 kb & 265 kb\\

In-place/out-place transformations & in-place &
in-place & out-place  & out-place \\

\hline
\end{tabular}
\caption{Comparing model transformation tools.}
\label{tab:comparing}
\end{table} 

\subsection{Meta-modeling}

Through defining the abstract syntax is where our editor has its biggest
advantage. The transformation tools that we worked with has a two layered
approach to modeling. First we create the abstract syntax through a meta-model
and second we specify the concrete syntax through a instance model of this
abstract syntax. This is also implicitly true for the Transform Editor, since
every DPF model, regardless of abstraction layer is represented as an instance
model of some abstract syntax model. But this abstract syntax model also
specifies that every DPF model also is an instance of DPF model that are one
abstraction layer higher. So one could say that every DPF model is an instance
of a common modeling language while the abstract syntax for the modeling
elements for this DPF model are typed by another DPF model. With the help of
application conditions we can adapt the Henshin transformation language to make
it possible to apply model transformations to a modeling language that is
specified through an unlimited hierarchy layer of meta-modeling. AGG on the
other hand specifies the abstract syntax in a type graph, that contains both the
source and target meta-model. In AGG we can then create a instance graph that
where modeling elements correspond to modeling elements of the type graph.  

\subsection{Rule Application Control}

The Transformation Editor does not provide the user with any control regarding
how to locate matches and how transformation rules are applied. Whereas ATL
provides the user with 

\subsection{Source - Target Relationship}

\subsection{Directionality}

\subsection{Tracing}


\section{Conclusion}

We have experienced that after working with the three tools that in the initial
learning phase both AGG and Henshin seems to be more intuitive to use because of the
graphical editor they provide. Because of the extensive language OCL, ATL
requires more hours to understand compared to AGG and Henshin. Its important to
take into consideration that I have read through papers that explain the
principles behind graph transformations. This makes it easier to understand how
AGG and Henshin introduces the users to model transformation, even though both
tools have different solutions to how graph transformation is implemented. But
learning a new programming language requires time. And therefore a graphical
solution might feel more intuitive then a textual solution. However I also know
that if you master a programming language, then writing code is more productive
compared to using a graphical editor. Therefore if the user master both the ATL
transformation language and the OCL programming language then it might be a
productive way of creating transformation rules. All these three tools have gone
through several iterations and releases and also have received feedback from the
user community. This only reassure me that all these three tools are viable
choices for model transformations. Most of the hours have been spent on
Henshin's working with the graphical editor and programmatically
invoking the Henshin interpreter. The graphical editor provides a clear
process of defining new transformation rules once I understood how the graph
transformation principles worked for Henshin. The Henshin Interpreter has
an extensive API that can be used to programmatically translate the
models. The interpreter still requires a set of Henshin rules to be able to
initiate a model transformation, but this means that the user can create its own
graphical editor and integrate this editor with Henshin to manipulate models.
Together with the Henshin Model Editor, the graphical editor and the Henshin
Interpreter Henshin provides a very viable transformation language for model
