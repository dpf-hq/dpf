% Chapter Template

\chapter{Evaluation} % Main chapter title

\label{Chapter6} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 6. \emph{Evaluation}} % Change X to a consecutive
% number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Evaluation of Solution}
\label{evaluate_solution}
We have successfully managed to integrate Henshin with the Diagram Predicate
Framework to support exogenous model transformations. We have created a
Transformation Editor that communicates with the Henshin transformation language
and the interpreter engine to deliver a model transformation environment to DPF.
We can use some of the strengths that Henshin provides

\section{Future Work}

\subsection{Graphical syntax representation of Transformed models}

\subsection{Making the Model Transformation constraint aware}

%----------------------------------------------------------------------------------------
% SECTION 2
%----------------------------------------------------------------------------------------

\section{Comparison with other editor tools}

In section~\ref{comparison} we compared strength and weaknesses of different
model transformation tools. Now that we have extended the DPF workbench
environment with the possibility to perform model to model transformations, we
should compare it with other model transformation tools. In our solution we
expanded the Henshin model transformation environment to be able to apply model
transformations to a multi-layered meta-modeling environment like we discussed
in section~\ref{evaluate_solution}. It is natural that the Transformation
Editor will have some similarities to the Henshin environment since our
solutions builds heavily on on this environment.

\subsection{Editing Transformation Rules}

In the Transformation Editor we present the transformation rules in a list of
transformation rules. Each transformation rule is extended with a simplified
version of the DPF Editor and a toolbar that contains modeling elements from a
source and a target meta-model. With these modeling elements we can create and
structure a searching pattern and a replacement pattern for each transformation
rules. It is logical that the searching pattern and replacement pattern create
modeling elements that corresponds to the source and target meta-model, since
this is an exogenous model transformation between two different modeling
languages. In Henshin we can choose to create transformation rules in either the
tree based Henshin Model Editor or in a graph based editor. The Transformation
Editor that we created provides an integrated view on transformation rules,
similar to Henshin and GReAT\cite{GReAT}. This means that we do not provide
separate editors to implicitly edit the LHS and the RHS graphs like for
example AGG does. 

\begin{table}[ht]
\renewcommand*\arraystretch{1.2}
\centering
\begin{tabular}{| c | c | c | c | c |}
\hline
& AGG & Henshin & ATL & DPF Transform \\
\hline
Endogenous transformation & $\surd$ & $\surd$ & $\surd$ & \textcolor{red}{\textbf{---}}\\

Exogenous transformation & $\surd$ & $\surd$ & $\surd$ & $\surd$\\

Input Elements & 1\ldots n & 1\ldots n & 1\ldots n & 1\ldots n\\

Output Elements & 1\ldots n & 1\ldots n & 1\ldots n & 1\ldots n\\

Graphical editor & $\surd$ & $\surd$ & \textcolor{red}{\textbf{---}} & $\surd$
\\

Meta-modeling layers & 2 & 2 & 2 & $\infty$ \\

Separate meta-models & \textcolor{red}{\textbf{---}} &  $\surd$ &  $\surd$ &  $\surd$ \\

Integrated with EMF & \textcolor{red}{\textbf{---}} & $\surd$ & $\surd$ & $\surd$ \\ 

Model transformation file size & 200 kb & 80 kb & 4 kb & 265 kb\\

In-place/out-place transformations & in-place &
in-place & out-place  & out-place \\

\hline
\end{tabular}
\caption{Comparing model transformation tools.}
\label{tab:comparing}
\end{table} 

\subsection{Meta-modeling}

Through defining the abstract syntax is where our editor has its biggest
advantage. The transformation tools that we worked with has a two layered
approach to modeling. First we create the abstract syntax through a meta-model
and second we specify the concrete syntax through a instance model of this
abstract syntax. This is also implicitly true for the Transform Editor, since
every DPF model, regardless of abstraction layer is represented as an instance
model of some abstract syntax model. But this abstract syntax model also
specifies that every DPF model also is an instance of DPF model that are one
abstraction layer higher. So one could say that every DPF model is an instance
of a common modeling language while the abstract syntax for the modeling
elements for this DPF model are typed by another DPF model. With the help of
application conditions we can adapt the Henshin transformation language to make
it possible to apply model transformations to a modeling language that is
specified through an unlimited hierarchy layer of meta-modeling. AGG on the
other hand specifies the abstract syntax in a type graph, that contains both the
source and target meta-model. In AGG we can then create a instance graph that
where modeling elements correspond to modeling elements of the type graph.  

\subsection{Rule Application Control}

The Transformation Editor does not provide the user with any control regarding
how to locate matches and how transformation rules are applied. We generate a
Henshin module that contains a set of transformation rules. We can manipulate
the execution order of these transformation rules, but the algorithm that
Henshin uses to locate matching patterns in a source model is part of the
internal infrastructure of Henshin and cannot be manipulated. We can however
force the transformation rules to be executed in a given order. This version of
the Editor has no support defining a schedule mechanism that specifies how the
rules are applied and will for now only run the transformation rules
sequentially. We can decide the priority of the rules by changing the order
that they appear in the Transformation Editor, but this list will apply rules in
sequential order. Most of the transformation tools open to the public provides
solutions to manipulate the scheduling mechanism, for example ATL provides the
users the possibility to define rules as lazy rules and control how they are
applied. While AGG and the Henshin environment lets the users specify the
scheduling mechanism over a few predefined choices. 

Another thing that is special about our integration of Henshin is that locating
matches are handled differently. An application condition is initially meant to
restrict a transformation rule when locating matches. If application conditions
are not specified for a transformation rule in some 2 layered meta-modeling
transformation tool we will still locate a matching pattern that correspond to
modeling elements that are described in the abstract syntax. The application
condition has a vital role in our integration of Henshin, because the
application conditions are checked against the DPF model that are one
abstraction level higher. Without this application condition we would simply get
a target DPF model that has a list of nodes and arrows that conform to the
highest level of abstraction in DPF. The highest level of abstraction in DPF
is always a node and an arrow, that conforms to itself. So while a 2 layered
meta-modeling transformation tool would find matches in a source model that
correspond to the meta-model, the Transformation Editor would find matches to
the linguistic meta-model and not the ontological meta-model at some level of
abstraction. One could state that an application condition for a 2 layered
meta-modeling transformation tool is independent of the transformation rules
while our version the transformation rules are dependent on the application
conditions to be able to produce a correct target model. 

\subsection{Source - Target Relationship}

The Transformation Editor explicitly performs an out-place model
transformation. This means that we create a target model that is independent of
the source model. For all matching modeling elements we locate in the source
model we create in a target model. We then make sure to specify all the nodes
and arrows with its corresponding type from a specification that is located one
abstraction layer higher. AGG does this differently, since the source and target
model are the same model. Matches are located in the source model, while the
target model is updated in the same model. For an exogenous model transformation
it is required that ATL produce the target model in a separate file. Henshin on
the other hand provides in-place model transformations on the source model. But
when we invoke the Henshin interpreter engine programmatically we can check for
changes before and after exeuting a set of transformation rules. Henshin
transformation engine requires a set of transformation rules, and a graph that
contains the source model. This graph contains a list of all the modeling
elements that are part of the source model. This is why we can explicitly make a
model transformation out-place, by checking this list before and after the
transformation and adding translated elements to a target model. The interpreter
will locate matches in the source model through this graph and produce target
elements to this graph. 

\subsection{Directionality}

To provide a graph based model transformation with the possibility to translate
in both directions is not a simple task. Because then the tool will have to
provide arbitrary switching between source and target models, and therefore the
pattern and replacement graphs will have to be changed when they are switched.
This means that the LHS and the RHS part of a transformation rules have to be
switched out. This is not provided in the Transformation Editor. One could do
this in two steps, to first locate matches in a source model and produce a
target model and then do another model transformation where the source and
target part is switched. Both Henshin and AGG does not provide this since the
corresponding RHS and LHS graphs are created according to the abstract syntax of
the source and target model. 

\subsection{Tracing}

Henshin utilize the generic Trace model to execute an exogenous model
transformation. 

\section{Conclusion}

We have experienced that after working with the three tools that in the initial
learning phase both AGG and Henshin seems to be more intuitive to use because of the
graphical editor they provide. Because of the extensive language OCL, ATL
requires more hours to understand compared to AGG and Henshin. Its important to
take into consideration that I have read through papers that explain the
principles behind graph transformations. This makes it easier to understand how
AGG and Henshin introduces the users to model transformation, even though both
tools have different solutions to how graph transformation is implemented. But
learning a new programming language requires time. And therefore a graphical
solution might feel more intuitive then a textual solution. However I also know
that if you master a programming language, then writing code is more productive
compared to using a graphical editor. Therefore if the user master both the ATL
transformation language and the OCL programming language then it might be a
productive way of creating transformation rules. All these three tools have gone
through several iterations and releases and also have received feedback from the
user community. This only reassure me that all these three tools are viable
choices for model transformations. Most of the hours have been spent on
Henshin's working with the graphical editor and programmatically
invoking the Henshin interpreter. The graphical editor provides a clear
process of defining new transformation rules once I understood how the graph
transformation principles worked for Henshin. The Henshin Interpreter has
an extensive API that can be used to programmatically translate the
models. The interpreter still requires a set of Henshin rules to be able to
initiate a model transformation, but this means that the user can create its own
graphical editor and integrate this editor with Henshin to manipulate models.
Together with the Henshin Model Editor, the graphical editor and the Henshin
Interpreter Henshin provides a very viable transformation language for model
